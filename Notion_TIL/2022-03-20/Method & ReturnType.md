# 1. Method & ReturnType

## 어떻게 하면 한 번 개발한 소스코드를 다시 재사용할 수 있을까?   → 객체지향을 사용해보자!

---

### 메소드(Method)

메소드는 로직이나 기능을 구성하는 소스를 하나의  { } 로 묶는 것이다.

### 메소드의 명명규칙(Naming Conventions)

어떤 로직을 처리하는 경우 영어의 동사로 표현하자!

프로그램의 성격에 맞는 이름을 부여하.

단어를 두 개 이상 결합할 때는 CamelCase를 사용하자.

### 메소드의 특징 3가지

1. 반드시 자신을 구분할 수 있는 이름을 가진다
2. 메소드는 동작하는 데 있어 필요한 임의의 데이터를 가질 수 있다.
3. 필요하다면 결과를 반환해주는 기능도 있어야한다.

### 메소드 구조

main은 객체지향과 무관하다.

- **public  : 누구나 접근 가능하다라는 접근제한자**
- **void  : 메소드를 호출한 쪽에서 결과값(리턴 타입)을 얻을 수 없다.**
- **() : 이 기능을 실행하기 위해서 필요한 입력이 무엇인지 알려준다. ex.  필요한 데이터가 int인지, 파라미터가 1개인지 2개인지 etc.**

### 디버깅(Debugging) 이란

작성된 코드의 문제점을 찾는 작업을 말한다.

### 메소드의 장점

- 메소드를 만들어 주면 코드의 재사용이 가능하다.
- 메소드에 필요한 데이터를 입력받게 되면 매번 다른 데이터를 처리할 수 있다.

⇒ 메소드를 재사용하려면 매번 다른 값을 줄 수 있게끔 설계하라.

### 메소드의 파라미터(Parametar) = 인자(Argument),인수

어떤 메소드를 실행할 때 필요한 데이터를 말한다.

메소드를 실행할 때마다 매번 다른 데이터를 처리하기 위해서, 어떤 데이터를 입력할 수 있게 하는데 이것이 메소드의 파라미터이다.

메소드를 만들 때 들어오는 input 값에 다른 값을 줄 수 있도록 만들어 주는 것

- 메소드의 파라미터는 어떻게 정해야할까?
    1. 메소드에 들어가는 파라미터가 문자인지, 숫자인지 명확하게 하여 호출 받을 수 있도록, 가장 먼저 **파라미터의 타입(type)**을 지정하도록 한다.
        
        ### m.makeSum(1,100) → makeSum(int startValue, int endValue)
        
        입력받은 숫자 1이 startValue에 들어가고, 100이 endValue에 들어간다. 
        
        ```java
        public void makeSum(int startValue, int endValue){
        
        			int start = startValue; //파라미터로 들어온 데이터를 start에 할당
        			int end = endValue; //파라미터로 들어온 데이터를 end에 할당
        }
        // 이 메소드에 데이터를 input 하려면 반드시 int 타입의 데이터여야한다.
        // 메소드의 파라미터를 선언한다는 것은 '변수를 선언'하는 것과 같은 방식이다.
        // 첫 번째 들어온 데이터를 startValue, 두 번째 들어온 데이터를 endValue 변수에 담는다.
        ```
        
        ![Untitled](1%20Method%20&%20ReturnType%20b8f286320f87455a8ea838011e75be41/Untitled.png)
        
- 메소드의 파라미터는 메소드의 { } 범위 안으로 한정됩니다. 따라서 파라미터의 영향력(범위)도 그 안으로 한정됩니다.
    - makeSum( ) 안에 선언된 startValue, endValue라는 변수들은 메소드 안에서만 사용된다.
    - **스코프(Scope) : 변수의 범위**
- `SumMachine 코드`
    
    즉, 메소드의 파라미터라는 것은 특정한 로직에 필요한 약간씩 다른 데이터의 값을 넣어서 조금 더 **재사용을 높이기 위해서 사용**한다는 겁니다.
    
    ### **SumMachine m = new SumMachine( );**
    
    ⇒ makeSum()이라는 기능을보유하고 있는 기계를 만듭니다.
    
    ```java
    public class SumMachine {
    	public void makeSum(int startValue, int endValue){
    		int start = startValue;
    		int end = endValue;
    		int sum = 0;
    
    		for(int i = start; i <= end ; i++){
    		sum = sum + i;
    		}//end for\
    
    		System.out.println("시작값: " + start);
    		System.out.println("종료값: " + end);
    		System.out.println("총 합: "+ sum);
    	}
    
    	public static void main(String[] args) {
    		SumMachine m = new SumMachine();
    		m.makeSum(1,100);
    		m.makeSum(20,200);
    		m.makeSum(30,300);
    	}
    }
    -----------------------------------------------
    시작값: 1
    종료값: 100
    총 합: 5050
    시작값: 20
    종료값: 200
    총 합: 19910
    시작값: 30
    종료값: 300
    총 합: 44715
    ```
    

---

### 메소드의 리턴 타입(Return Type)

매소드를 실행하고 특정 타입의 결과를 반환해주겠다고 선언하는 것을 말한다. 그리고 그 결과 데이터를 ‘리턴 값’이라고 한다.

- 리턴 타입이 void 라는 선언은 결과 데이터를 반환하지 않겠다는 뜻
- 결과 데이터는 매번 달라지기 때문에 메소드의 선언에서 어떤 유형의 데이터가 나오는지만을 리턴 타입으로 지정해줍니다.
- 리턴 타입은 메소드를 실행한 결과 데이터를 지정된 타입으로 반환해준다는 표시

### 실행결과를 왜 반환해줄 때가 있는가?

메소드가 다른 결과들을 동시에 처리하지 못한다면 그건 너무 아쉬운 일이다. 그렇다면 매번 다른 결과값을 처리하기 위해 메소드를 일일히 고쳐야하나? 

→ *“**NO,** 메소드는 로직을 처리한 결과만을 호출한 쪽으로 다시 전달해주고, 반환된 결과물에 대한 처리는 호출한 쪽에서 알아서 하도록 분리해주자.”*

<aside>
💡 메소드에 **파라미터라는 장치를 통해서 매번 다른 상황에 대처**하도록 했다면, **메소드의 리턴 타입은 결과를 매번 다른 결과가 나오는 것을 처리**하기 위한 장치이다.

</aside>

### 메소드의 결과를 반환해줄 때는 리턴 타입을 'void'가 아닌 타입으로 반환

메소드의 **리턴값의 가장 중요한 판단 기준**은 특정한 **메소드를 실행한 후에 즉각적으로 그 메소드의 실행 결과를 알게 해주는 것이 좋은가**이다.

### public void makeSum(int startValue, int endValue){

⇒ void로 선언되었을 때의 의미는 이 메소드는 실행해도 결과를 알려주지 않는다는 뜻입니다.

### public int makeSum(int startValue, int endValue){

⇒ int로 선언되었다는 것은 메소드를 실행하면 반드시 int 타입의 데이터를 피드백해 주겠다는 의미

### return이라는 키워드

어떤 메소드가 리턴해주기로 했다면 반드시 메소드의 코드는 return이라는 코드를 작성한 부분이 실행되도록 작성되어야 합니다. 그렇지 않으면 컴파일이 되지 않습니다.

```java
public class SumMachine {
			public int makeSum(int startValue, int endValue){
					int start = startValue;
					int end = endValue;
					int sum = 0;

					for(int i = start; i <= end ; i++){
					sum = sum + i;
					}//end for
					return sum;
			}

			public static void main(String[] args) {
					SumMachine m = new SumMachine();
					int result1 = m.makeSum(1,100);
					int result2 = m.makeSum(20,200);
					int result3 = m.makeSum(30,300);

					System.out.println(result1);
					System.out.println(result2);
					System.out.println(result3);
			}
}
-------------------------------------------------
5050
19910
44715

 //결과를 반환한 이후의 작업은 메소드를 호출한 쪽의 몫이다. 메소드가 어떤 리턴 값을 반환해주었다고 해도, 그 결과를 받아서 처리하는 것은 호출한 쪽의 선택이라는 말이다.
```

<aside>
💡 **사실 return이라는 키워드의 진짜 의미는 '실행을 여기까지만'이라는 뜻이다. ‘현재 코드의 실행 제어권을 반환한다’라는 것이 더 명시적이겠다.**

</aside>

---

### 메소드의 구성 요소 정리

![Untitled](1%20Method%20&%20ReturnType%20b8f286320f87455a8ea838011e75be41/Untitled%201.png)

### 프로그램이 점점 커지면서 발생하는 상황

메소드를 하나 만든 후에 더 복잡하거나 다른 기능들을 추가하고 싶다! ⇒ 추가적인 개발이 요구되면 개발자들의 선택은 두 가지 中 하나이다.

- 기존에 개발해둔 메소드를 수정해서 사용하는 방법
- 기존 메소드를 수정하지 않고 새로운 메소드를 작성해서 같이 연동하게 만드는 방법

<aside>
💡 기능이나 절차가 많아지면 사용하기 불편해지고, 그것을 전문적으로 하는 사람들이 생기듯, 메소드가 많아
지고 데이터가 많아지면 그것을 알아서 처리할 수 있는 존재를 생각해볼 수 있는데 객체지향에서 바로 이
런 존재를 **객체(Object)**라고 합니다.

</aside>

### 객체지향에서 객체는 로직(기능)뿐 아니라 데이터도 스스로 관리한다.

객체지향 프로그래밍에서 말하는 객체(Object)라는 것이 편리하다고 생각하는 가장 중요한 이유는 코드를 호출하는 입장에서 편하다. 알아서 데이터를 보관하기 때문에 그만큼 신경 써야 하는 일이 줄어든다. 

**같은 로직을 가지지만 때에 따라서 다른 데이터를 보관할 수 있는 방식의 프로그램을 만드는 것**, 이것이 바로 객체지향 프로그래밍의 핵심입니다